# El siguiente codigo esta escrito en pyhton al 07/02/204. 
# Aspectos importantes para su ejecucion: 
# 	-Intalar driver --> "ODBC Driver 17 for SQL Server", 
# 	  en caso de tener una version posterior cambiar el 
#	  nombre del driver en la variable driver, (Linea 16)
#	-El codigo funciona con Chrome, por lo tanto es necesario
#	  tener descargado chromedriver.exe y ubicado en la ruta: 
#	  "C:/Program Files/Google/Chrome/Application/chromedriver.exe"
#	  del equipo. Si se almacena en otro lugar cambiar la ruta
#	  en la variable service, (linea 27) aunque esto impicaria
#	  volver a crear un ejecutable para el codigo.


# Librerias necesarias para el funcionamiento. 
import pyodbc
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import pandas as pd
from selenium.webdriver.chrome.options import Options


#  ------ Configuración de acceso y conexiona SQL Server ------ 

# Tal como se enlista acontinuacion se solicita la informacion: 
    # -Nombre del servidor.
    # -Nombre de la base de datos.
    # -Usuario servidor.
    # -Contraseña servidor.
    # -Nombre del driver a utilizar.

server = '172.16.137.51'
database = 'Sinergia_Aux'
username = 'nf2'

password = 'nf@qwe'
driver = 'ODBC Driver 17 for SQL Server'

# Se crea una cadena de conexion con los datos de acceso a sql 
conn_str = f'DRIVER={driver};SERVER={server};DATABASE={database};UID={username};PWD={password}'

# Establecer la conexión
conn = pyodbc.connect(conn_str)

# Crear un cursor para ejecutar consultas SQL
cursor = conn.cursor()

# ------ Fin de configuracion del acceso al servidor ------ 



# Configuración de Selenium
# Para establecer las opciones del driver se llama 
#   a el modulo webdriver y a la classe ChromeOptions  
options = webdriver.ChromeOptions()
# Con el metodo add.argument agregamos las opciones para nuestro navegador,
#   en este caso solo agregamos "--headless" para que no se actualice 
#   la pantalla mientras se ejecuta el codigo.
options.add_argument("--headless")
# Con service se establece la ruta de la ubicacion del driver para Chrome.
service = ChromeService(executable_path="C:/Program Files/Google/Chrome/Application/chromedriver.exe")
# En driver se utilizan los parametros declarados en la variable service 
#   y la variable options para el uso del navegador. 
driver = webdriver.Chrome(service=service, options=options)

# Iniciar sesión en el sitio web
# Se guarda la pagina a visitar en la variable pagina_de_inicio.
pagina_de_inicio = 'https://www.comercialrefinacion.pemex.com/portal/'
# Pagina donde se encuentra la informacion del volumen restituido.
pagina_volumen_restituido = 'https://www.comercialrefinacion.pemex.com/portal/sccli040/controlador?Destino=sccli040_01.jsp#'
# Con la variable driver y la funcion .get establecemos la conexion a la pagina de inicio. 
driver.get(pagina_de_inicio)
# Usario y contraseña para acceder a el PortalPemex
usuario_Pmx = '0001500759'
contrasena_pmx = 'ztgb9078'

# Con la variable driver y la funcion .find_element se establecen los elementos
#   por los cuales se va a navegar en la pagina. Estos elementos se obtienen de las
#   etiquetas del html de la pagina.

# Se dirige a el elemento 'usuario' de la pagina e ingresa nuestro usuario de acceso.
driver.find_element(By.NAME,'usuario').send_keys(usuario_Pmx)
# Se dirige a el elemento 'contrasena' de la pagina e ingresa nuestra contraseña de acceso.
driver.find_element(By.NAME,'contrasena').send_keys(contrasena_pmx)
# Se dirige a el elemento 'botonEntrar' de la pagina y lo oprime. 
driver.find_element(By.NAME,'botonEntrar').send_keys(Keys.ENTER)

# ------ En este momento ya hicimos login en la pagina ------ 

# Nuestro driver espera 5 seg a que aparezca el 
#   elemento 'textoEjecutivo' para continuar con el codigo.

# ------ Valida que se conecto a la pagina buscando un elemento que solo es accesible despues del login ------ 

wait = WebDriverWait(driver, 5)
# Esta parte es opcional 
# nombre_user_activo_pmx = wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'textoEjecutivo')))
# print(nombre_user_activo_pmx.text)

# ------ Equi se dirige a la pagina que incluye el volumen restituido ------ 

driver.get(pagina_volumen_restituido)
driver.find_element(By.XPATH,"//input[@value='Consultar']").send_keys(Keys.ENTER)
datos_de_tabla_volumenrestituido = driver.find_element(By.XPATH,"//form[@action='/portal/sccli040/controlador']/following-sibling::table[1]")

print(datos_de_tabla_volumenrestituido.text)

# Obtener datos de la tabla y dividirlos en filas y columnas
filas = datos_de_tabla_volumenrestituido.find_elements(By.TAG_NAME, 'tr')
columnas = filas[0].find_elements(By.TAG_NAME, 'th')  # Se asume que la primera fila contiene encabezados

# Crear un DataFrame de pandas con los datos
data = []
for fila in filas[1:]:

    celdas = fila.find_elements(By.TAG_NAME, 'td')
    fila_data = [celda.text for celda in celdas]
    data.append(fila_data)

df = pd.DataFrame(data, columns=[celda.text for celda in columnas])
# Descartar los últimos 20 registros del DataFrame
df = df.iloc[:-2]
print(df)

# (Opcional) df.to_excel('C:/Users/AdminTI/OneDrive - Sinergia/Escritorio/datos_volumen_restituido.xlsx')

# Nombres de las columnas en el DataFrame
nombres_columnas_df = df.columns.tolist()

# Mapear nombres de columnas a nombres de columnas en la tabla SQL Server
mapeo_columnas = {
    'Fecha de operación': 'Fecha_de_operacion',
    'Permiso CRE': 'Permiso_CRE',
    'Comprobante de carga': 'Comprobante_de_carga',
    'Remisión': 'Remision',
    'Producto': 'Producto',
    'Volumen comprobante de carga(lts)': 'Volumen_comprobante_de_carga',
    'Volumen total de factura(lts)': 'Volumen_total_de_factura',
    'Volumen a restituir (lts)': 'Volumen_a_restituir',
    'Cliente': 'Cliente',
    'Destino': 'Destino'
}

# Renombrar columnas en el DataFrame
df.rename(columns=mapeo_columnas, inplace=True)
df['Fecha_de_operacion'] = df['Fecha_de_operacion'].astype(str)
df['Permiso_CRE'] = df['Permiso_CRE'].astype(str)
df['Comprobante_de_carga'] = df['Comprobante_de_carga'].astype(str)
df['Remision'] = df['Remision'].astype(str)
df['Producto'] = df['Producto'].astype(str)
df['Volumen_comprobante_de_carga'] = df['Volumen_comprobante_de_carga'].apply(lambda x: float(x.replace(',', '')) if x.replace(',', '').replace('.', '').isdigit() else None)
df['Volumen_total_de_factura'] = df['Volumen_total_de_factura'].apply(lambda x: float(x.replace(',', '')) if x.replace(',', '').replace('.', '').isdigit() else None)
df['Volumen_a_restituir'] = df['Volumen_a_restituir'].apply(lambda x: float(x.replace(',', '')) if x.replace(',', '').replace('.', '').isdigit() else None)
df['Cliente'] = df['Cliente'].astype(str)
df['Destino'] = df['Destino'].astype(str)

print(df)

# Ahora, los nombres de las columnas en el DataFrame coinciden con los de la tabla SQL Server
# Agregar datos a la tabla Volumen_Restituido en SQL Server
tabla_destino = 'Volumen_Restituido'
for index, row in df.iterrows():
    # Construir la consulta de inserción
    query = f"INSERT INTO {tabla_destino} (Fecha_de_operacion, Permiso_CRE, Comprobante_de_carga, Remision, Producto, Volumen_comprobante_de_carga, Volumen_total_de_factura, Volumen_a_restituir, Cliente, Destino) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
    
    # Ejecutar la consulta con los valores de la fila actual
    try:
        cursor.execute(query, tuple(row))
    except pyodbc.Error as ex:
        # Manejar el caso en que el valor sea None y sustituirlo con NULL en la consulta
        if 'NoneType' in str(ex) and 'Parameter 9' in str(ex):
            row = [None if pd.isna(value) else value for value in row]
            cursor.execute(query, tuple(row))
        else:
            raise ex

query_2 = ("UPDATE Volumen_Restituido SET CodigoInstalacion = LEFT(Destino, CHARINDEX('-', Destino) - 1);")

cursor.execute(query_2)

# """ query_3 = ("""with C as (
#	select  id, comprobante_de_carga, Remision, 
#	ROW_NUMBER() over (
#						PARTITION BY comprobante_de_carga 
#						ORDER BY comprobante_de_carga desc 
#						) 
#					AS DUPLICADO 
#	FROM Volumen_Restituido
#)""")
#
# cursor.execute(query_3)


# Confirmar los cambios en la base de datos
conn.commit()

# Cerrar la conexión a SQL Server
conn.close()

# A partir de esta parte se procede con el cierre de sesion
driver.find_element(By.XPATH,"//ul[@id='nav']/li[4]/a[1]").click()
validacion = wait.until(EC.presence_of_element_located((By.XPATH,"//p[text()=' Contraseña : ']")))

if validacion.text == 'Contraseña :':
    print('Cierre de sesión completado con exito')
else:
    print('No se ha podido cerrar la sesion')

driver.quit()